[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fuzzing Book Chapter 1 Reading",
    "section": "",
    "text": "Picture of me above\n\n\nHello, my name is Sabrina Rodriguez, and I am looking forward to collaborating with everyone throughout the semester."
  },
  {
    "objectID": "index.html#se1",
    "href": "index.html#se1",
    "title": "Fuzzing Book Chapter 1 Reading",
    "section": "SE1",
    "text": "SE1\n\nSummary\nThis chapter discusses the significance of software engineering and provides an overview of how organization serves as a foundational principle in this field. The book’s authors highlight the evolution of programming development over time and emphasize essential considerations for effective programming.\n\n\nReflection\nI believe that the book has key insights on how to create efficient code that allows for improvement over time. Specifically in reducing redundant code, improving organization, and bettering time-cost trade-offs.\n\n\nUse-Case\nThis book will enable us to efficiently execute code that Chasten can review and use as a test-case environment."
  },
  {
    "objectID": "index.html#fb1",
    "href": "index.html#fb1",
    "title": "Fuzzing Book Chapter 1 Reading",
    "section": "FB1",
    "text": "FB1\n\nSummary\nThe first chapter of Fuzzingbook discusses some attributes of python such as creating test cases and debugging specific code. Test cases are an upmost importance when writing and distributing code to other users. Test cases ensure that the program is working for all scenarios, which is why the chapter goes into depth of different ways to test a program. It also discusses the benefits of debugging code within the very coding process, in order to avoid bugs for larger programs. There are the benefits writing test cases, but the chapter also describes the obstacles and difficulty when doing so, such as untested inputs where a function is still likely to fail. The authors describe different behaviors of different functions and how few programs can accurately give a correct output in most case scenarios. Despite these faults, test cases are extremely important to have in a program as they allow for effective results and aim for an error free code.\n\n\nReflection\nThe chapter was an amazing refresher on how to utilize specific python commands and methods to write efficient code. Specifically referring to test cases, I struggly writing test cases in general and have a difficult time understanding how to fully utilize its use, with this chapter in mind, I can definitely refer to it for future purposes. Implementing code in Chasten knowing how to effectively and efficiently write test cases can help tremendously within the process of making the program.\n\n\nUse-Case\nFor example, one way to test a python program is by manually making a test case to automate test:\n    result = my_sqrt(4)\nexpected_result = 2.0\nif result == expected_result:\n    print(\"Test passed\")\nelse:\n    print(\"Test failed\")\nproducing the output:\nTest passed\nHowever, this is not an efficient way to write test cases, as it only allows for one correct answer and not a rounded answer or an integer as a result, it also takes up many lines of code. A more effective way to write a test case is by making it more compact using an assertion statement, which is used to take a condition and evaluate whether it is true or not (similar to a Yield statement):\nassert my_sqrt(4) == 2\nAnother example of producing an effective test case is through Run-Time Verification, which is a method of analyzing extracting data from a system and identifies behaviors that meet or breach a specific criteria. An example the book provides of a Run-Time Verification is seen below:\ndef my_sqrt_checked(x):\n    root = my_sqrt(x)\n    assertEquals(root * root, x)\n    return root\n\nmy_sqrt_checked(2.0)\nproducing the result:\n1.414213562373095\nThe chapter also touched on the importance of debugging programs in a specific manner to ensure errors will not occur frequently throughout the programmers journey of writing their code. There are two different methods the chapter touched on which involve writing a print statement after every line to ensure there is a correct output:\ndef my_sqrt_with_log(x):\n    \"\"\"Computes the square root of x, using the Newton–Raphson method\"\"\"\n    approx = None\n    print(approx)\n    guess = x / 2\n    while approx != guess:\n        print(\"approx =\", approx)  # &lt;-- New\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\nmy_sqrt_with_log(9)\nproducing the output:\nNone\napprox = None\napprox = 4.5\napprox = 3.25\napprox = 3.0096153846153846\napprox = 3.000015360039322\napprox = 3.0000000000393214\nOut[30]:\n3.0\nThe other method is using a %%debug method to debug your code:\n%%debug\ndef my_sqrt_with_log(x):\n    \"\"\"Computes the square root of x, using the Newton–Raphson method\"\"\"\n    approx = None\n    print(approx)\n    guess = x / 2\n    while approx != guess:\n        print(\"approx =\", approx)  # &lt;-- New\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\nNOTE: Enter 'c' at the ipdb&gt;  prompt to continue execution.\n&gt; &lt;string&gt;(2)&lt;module&gt;()\n\nipdb&gt; c\nmy_sqrt_with_log(9)\n\nNone\napprox = None\napprox = 4.5\napprox = 3.25\napprox = 3.0096153846153846\napprox = 3.000015360039322\napprox = 3.0000000000393214\nOut[34]:\n3.0\nThese are some of the methods the chapter disscuessed in terms of using debugging methods and writing test cases."
  }
]